#!/usr/bin/env node
// backend/bin/www
const { port } = require('../config');
const socket = require("socket.io");
const app = require('../app');
const { get_Current_User, user_Disconnect, join_User,join_User_Voice, user_online } = require("../utils/server");
const db = require('../db/models');
const { TextChannel, DirectMessage, User } = require("../db/models")

const { Op } = require('sequelize');


// Check the database connection before starting the app
let io;
db.sequelize
  .authenticate()
  .then(() => {
    console.log('Database connection success! Sequelize is ready to use...');

    // Start listening for connections
    let server = app.listen(port, () => console.log(`Listening on port ${port}...`));
    io = socket(server,{
      pingTimeout: 3000,
      pingInterval: 3000
    });

    io.on("connection", (socket) => {
      //for a new user joining the room


      socket.on("addedFriend", async ({ notify, userId  }) => {


        let user = await User.findByPk(userId)
        let otherUser = await User.findByPk(notify)
        io.emit("youGotAdded", {
          user, otherUser
        })
      })


      socket.on("online", async ({ username, userId }) => {
        let online = user_online(socket.id, username, userId)
        let userUpdate = await User.findByPk(userId)
        let oldProfilePicture = userUpdate.profilePicture
        let oldEmail = userUpdate.email
        let oldHashed = userUpdate.hashedPassword
        let newBody = {
          profilePicture: oldProfilePicture,
          username,
          email: oldEmail,
          hashedPassword: oldHashed,
          online: true
        }
        let userUpdated = await userUpdate.update(newBody)
        io.emit("loggedOn", {
          userId
        })
      })

      socket.on("DMCreation", ({userId, friendId}) =>{
        io.emit("updateDM", {
          userId,
          friendId
        })

      })

      socket.on("joinRoom", ({ username, roomId, picture }) => {
        //* create user

        const p_user = join_User(socket.id, username, roomId, picture);
        console.log(socket.id, "=id");
        socket.join(p_user.room);

      });

      socket.on("joinVoice", ({ username, voiceRoomId}) => {
        //* create user

        const p_user = join_User_Voice(username, voiceRoomId);
        console.log(socket.id, "=id");
        let rooms =[p_user.room, p_user.voiceRoom]
        socket.join(rooms);

      })

      //user sending message
      socket.on("chat", async (payload) => {
        //gets the room user and the message sent
        const { text, textId } = payload
        const p_user = get_Current_User(socket.id);

        let toUpdate = await TextChannel.findByPk(parseInt(textId))
        let oldChannelName = toUpdate.channelName
        let oldServerId = toUpdate.serverId
        let oldMessageHistory = toUpdate.messageHistory

        if (oldMessageHistory.length < 30) {
          let newBody = {
            channelName: oldChannelName,
            serverId: oldServerId,
            messageHistory: [...oldMessageHistory, { date: new Date(), username: p_user.username, picture: p_user.picture, text: text }]
          }
          const updated = await toUpdate.update(newBody)
          io.to(p_user.room).emit("message", {


            text: updated.messageHistory
          });
        } else {
          let remove = oldMessageHistory.shift()
          let newBody = {
            channelName: oldChannelName,
            serverId: oldServerId,
            messageHistory: [...oldMessageHistory, { date: new Date(), username: p_user.username, picture: p_user.picture, text: text }]
          }
          const updated = await toUpdate.update(newBody)
          io.to(p_user.room).emit("message", {


            text: updated.messageHistory
          });
        }
      });
      socket.on("dm", async (payload) => {
        console.log('are you working ###', socket.id)
        const { text, userId, otherId } = payload
        const p_user = get_Current_User(socket.id);
        const toUpdate = await DirectMessage.findOne({
          where: {
            [Op.or]: [
              {
                [Op.and]: [
                  { user1: userId },
                  { user2: otherId }
                ]
              },
              {
                [Op.and]: [
                  { user1: otherId },
                  { user2: userId }
                ]
              }
            ]
          }
        })

        let oldUser1 = toUpdate.user1
        let oldUser2 = toUpdate.user2
        let oldMessageHistory = toUpdate.messageHistory


        if (oldMessageHistory.length < 30) {
          let newBody = {
            user1: oldUser1,
            user2: oldUser2,
            messageHistory: [...oldMessageHistory, { date: new Date(), username: p_user.username, picture: p_user.picture, text: text }]
          }

          const updated = await toUpdate.update(newBody)
          io.to(p_user.room).emit("DMmessage", {
            userId,
            text: updated.messageHistory
          });
        } else {
          let remove = oldMessageHistory.shift()
          let newBody = {
            user1: oldUser1,
            user2: oldUser2,
            messageHistory: [...oldMessageHistory, { date: new Date(), username: p_user.username, picture: p_user.picture, text: text }]
          }

          const updated = await toUpdate.update(newBody)
          io.to(p_user.room).emit("DMmessage", {
            userId,
            text: updated.messageHistory
          });
        }

      })

      //when the user exits the room
      socket.on("disconnect", async (reason) => {
        //the user is deleted from array of users and a left room message displayed
        const p_user = user_Disconnect(socket.id);
        console.log("###reason", reason)
        if (p_user) {
          let userUpdate = await User.findByPk(p_user)
          let oldProfilePicture = userUpdate.profilePicture
          let oldEmail = userUpdate.email
          let oldHashed = userUpdate.hashedPassword
          let oldUsername = userUpdate.username
          let newBody = {
            profilePicture: oldProfilePicture,
            username: oldUsername,
            email: oldEmail,
            hashedPassword: oldHashed,
            online: false
          }
          let userUpdated = await userUpdate.update(newBody)
          io.emit("loggedOff", {
            userId: userUpdated.id
          })
        }

      });
    });

  })
  .catch((err) => {
    console.log('Database connection failure.');
    console.error(err);
  });
